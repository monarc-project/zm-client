<?php declare(strict_types=1);
/**
 * @link      https://github.com/monarc-project for the canonical source repository
 * @copyright Copyright (c) 2016-2024 Luxembourg House of Cybersecurity LHC.lu - Licensed under GNU Affero GPL v3
 * @license   MONARC is licensed under GNU Affero General Public License version 3
 */

namespace Monarc\FrontOffice\Import\Processor;

use Monarc\Core\Entity\Anr;
use Monarc\FrontOffice\Entity;
use Monarc\FrontOffice\Import\Helper\ImportCacheHelper;
use Monarc\FrontOffice\Service\AnrVulnerabilityService;
use Monarc\FrontOffice\Table\VulnerabilityTable;

class VulnerabilityImportProcessor
{
    public function __construct(
        private VulnerabilityTable $vulnerabilityTable,
        private ImportCacheHelper $importCacheHelper,
        private AnrVulnerabilityService $anrVulnerabilityService
    ) {
    }

    public function processVulnerabilitiesData(Entity\Anr $anr, array $vulnerabilitiesData): void
    {
        $this->prepareVulnerabilityUuidsAndCodesCache($anr);
        foreach ($vulnerabilitiesData as $vulnerabilityData) {
            $this->processVulnerabilityData($anr, $vulnerabilityData);
        }
    }

    public function processVulnerabilityData(Entity\Anr $anr, array $vulnerabilityData): Entity\Vulnerability
    {
        $vulnerability = $this->getVulnerabilityFromCacheOrDb($anr, $vulnerabilityData['uuid']);
        if ($vulnerability !== null) {
            return $vulnerability;
        }

        /* The code should be unique. */
        if ($this->importCacheHelper->isItemInArrayCache('vulnerabilities_codes', $vulnerabilityData['code'])) {
            $vulnerabilityData['code'] .= '-' . time();
        }

        /* In the new data structure there is only "label" field set. */
        if (isset($vulnerabilityData['label'])) {
            $vulnerabilityData['label' . $anr->getLanguage()] = $vulnerabilityData['label'];
        }
        if (isset($vulnerabilityData['description'])) {
            $vulnerabilityData['description' . $anr->getLanguage()] = $vulnerabilityData['description'];
        }

        $vulnerability = $this->anrVulnerabilityService->create($anr, $vulnerabilityData, false);
        $this->importCacheHelper->addItemToArrayCache('vulnerabilities', $vulnerability, $vulnerability->getUuid());

        return $vulnerability;
    }

    public function getVulnerabilityFromCacheOrDb(Entity\Anr $anr, string $uuid): ?Entity\Vulnerability
    {
        $vulnerability = $this->importCacheHelper->getItemFromArrayCache('vulnerabilities', $uuid);
        /* The current anr vulnerabilities' UUIDs are preloaded, so can be validated first. */
        if ($vulnerability === null && $this->importCacheHelper->isItemInArrayCache('vulnerabilities_uuids', $uuid)) {
            /** @var ?Entity\Vulnerability $vulnerability */
            $vulnerability = $this->vulnerabilityTable->findByUuidAndAnr($uuid, $anr, false);
        }

        return $vulnerability;
    }

    public function prepareVulnerabilityUuidsAndCodesCache(Entity\Anr $anr): void
    {
        if (!$this->importCacheHelper->isCacheKeySet('vulnerabilities_uuids')) {
            foreach ($this->vulnerabilityTable->findUuidsAndCodesByAnr($anr) as $data) {
                $this->importCacheHelper
                    ->addItemToArrayCache('vulnerabilities_uuids', (string)$data['uuid'], (string)$data['uuid']);
                $this->importCacheHelper->addItemToArrayCache('vulnerabilities_codes', $data['code'], $data['code']);
            }
        }
    }
}
