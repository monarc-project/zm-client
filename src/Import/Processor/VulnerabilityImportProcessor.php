<?php declare(strict_types=1);
/**
 * @link      https://github.com/monarc-project for the canonical source repository
 * @copyright Copyright (c) 2016-2024 Luxembourg House of Cybersecurity LHC.lu - Licensed under GNU Affero GPL v3
 * @license   MONARC is licensed under GNU Affero General Public License version 3
 */

namespace Monarc\FrontOffice\Import\Processor;

use Monarc\Core\Entity\Anr;
use Monarc\FrontOffice\Entity;
use Monarc\FrontOffice\Import\Helper\ImportCacheHelper;
use Monarc\FrontOffice\Service\AnrVulnerabilityService;
use Monarc\FrontOffice\Table\VulnerabilityTable;

class VulnerabilityImportProcessor
{
    public function __construct(
        private VulnerabilityTable $vulnerabilityTable,
        private ImportCacheHelper $importCacheHelper,
        private AnrVulnerabilityService $anrVulnerabilityService
    ) {
    }

    public function processVulnerabilitiesData(Entity\Anr $anr, array $vulnerabilitiesData): void
    {
        $this->prepareVulnerabilitiesAndCodesCache($anr);
        foreach ($vulnerabilitiesData as $vulnerabilityData) {
            $this->processVulnerabilityData($anr, $vulnerabilityData);
        }
    }

    public function processVulnerabilityData(Entity\Anr $anr, array $vulnerabilityData): Entity\Vulnerability
    {
        $vulnerability = $this->getVulnerabilityFromCache($vulnerabilityData['uuid']);
        if ($vulnerability !== null) {
            return $vulnerability;
        }

        /* The code should be unique. */
        if ($this->importCacheHelper->isItemInArrayCache('vulnerabilities_codes', $vulnerabilityData['code'])) {
            $vulnerabilityData['code'] .= '-' . time();
        }

        /* In the new data structure there is only "label" field set. */
        if (isset($vulnerabilityData['label'])) {
            $vulnerabilityData['label' . $anr->getLanguage()] = $vulnerabilityData['label'];
        }
        if (isset($vulnerabilityData['description'])) {
            $vulnerabilityData['description' . $anr->getLanguage()] = $vulnerabilityData['description'];
        }

        $vulnerability = $this->anrVulnerabilityService->create($anr, $vulnerabilityData, false);
        $this->importCacheHelper->addItemToArrayCache('vulnerabilities', $vulnerability, $vulnerability->getUuid());

        return $vulnerability;
    }

    public function getVulnerabilityFromCache(string $uuid): ?Entity\Vulnerability
    {
        return $this->importCacheHelper->getItemFromArrayCache('vulnerabilities', $uuid);
    }

    public function prepareVulnerabilitiesAndCodesCache(Entity\Anr $anr): void
    {
        if (!$this->importCacheHelper->isCacheKeySet('vulnerabilities_uuids')) {
            /** @var Entity\Vulnerability $vulnerability */
            foreach ($this->vulnerabilityTable->findByAnr($anr) as $vulnerability) {
                $this->importCacheHelper->addItemToArrayCache(
                    'vulnerabilities',
                    $vulnerability,
                    $vulnerability->getUuid()
                );
                $this->importCacheHelper->addItemToArrayCache(
                    'vulnerabilities_codes',
                    $vulnerability->getCode(),
                    $vulnerability->getCode()
                );
            }
        }
    }
}
